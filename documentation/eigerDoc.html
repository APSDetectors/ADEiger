<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>areaDetector Eiger driver</title>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type" />
</head>
<body>
  <div style="text-align: center">
    <h1> areaDetector Eiger driver</h1>
    <h2> December 18, 2015</h2>
    <h2> Bruno Martins<br/>Diego Omitto<br/> Brookhaven National Laboratory</h2>
  </div>
  <h2> Table of Contents</h2>
  <ul>
    <li><a href="#Introduction">Introduction</a></li>
    <li><a href="#Trigger_Modes">Trigger Modes</a></li>
    <li><a href="#Manual_Trigger">Manual Trigger</a></li>
    <li><a href="#Data_Acquisition">Data Acquisition</a></li>
    <ul>
      <li><a href="#Using_FileWriter">Using FileWriter</a></li>
      <li><a href="#Using_Stream">Using Stream</a></li>
      <li><a href="#Using_Monitor">Using Monitor</a></li>
    </ul>
    <li><a href="#StandardNotes">Implementation of standard driver parameters</a></li>
    <li><a href="#Driver_parameters">Eiger specific parameters</a></li>
    <li><a href="#Unsupported">Unsupported standard driver parameters</a></li>
    <li><a href="#Configuration">Configuration</a></li>
    <li><a href="#CSS_screen">CSS screen</a></li>
    <li><a href="#Known_Issues">Known Issues</a> </li>
    <ul>
      <li><a href="#Changing_the_Photon_Energy">Changing the Photon Energy</a></li>
      <li><a href="#Status_Parameters_Polling">Status Parameters Polling</a></li>
      <li><a href="#Internal_Enable_Mode">Internal Enable Mode</a></li>
    </ul>
  </ul>
  <h2 id="Introduction" style="text-align: left">Introduction</h2>
    <p>
      This is an <a href="http://www.aps.anl.gov/epics">EPICS</a> <a href="areaDetector.html">
      areaDetector</a> driver for the Eiger detector from <a href="http://www.dectris.com">Dectris</a>.
      It has been tested on the Eiger 1M, 4M and 16M with the firmware version 1.5.0. The driver
      communicates with the detector via its SIMPLON REST interface, so no library from Dectris is required.
      The images can pulled from the detector as HDF5 files, as a ZeroMQ stream or both. The files can be
      both saved to disk and passed to the areaDetector pipeline at the same time.
    </p>
    <p> All trigger modes are supported, although Internal Enable mode seems to not be working
      properly. See Known Issues.</p>
    <p>
      This driver inherits from <a href="areaDetectorDoc.html#ADDriver">ADDriver</a>.
      It implements many of the parameters in <a href="areaDetectorDoxygenHTML/asyn_n_d_array_driver_8h.html">
      asynNDArrayDriver.h</a> and in <a href="areaDetectorDoxygenHTML/_a_d_driver_8h.html">
      ADArrayDriver.h</a>. It also implements a number of parameters that are specific
      to the Eiger detector. The <a href="areaDetectorDoxygenHTML/classeiger_detector.html">eigerDetector
      class documentation</a> describes this class in detail.
    </p>
    <p>
      This document does not attempt to explain the meaning of the Eiger-specific parameters, as they
      are explained in the SIMPLON API Reference and in the EIGER Detector Manual documents from Dectris.
      Sometimes it does, however, refer to those parameters as they are named in Dectris' documentation.
    </p>
    <p>
      The SIMPLON API provides ways to query parameter limits, valid values for enums, error conditions, etc,
      but those features are not currently in use. Setting a parameter will immediately push its value to the
      detector and it can reject the update if the value is outside of the acceptable range.
    </p>
    <p>
      This driver was built upon a multithreaded architecture. A combination of threads is used to simultaneously
      pull files from the detector, save them to disk and parse them into NDArrays. A dedicated thread is used to
      receive images in a ZeroMQ stream.
    </p>
    <p>
      A few Eiger parameters are set at IOC initialization time and are expected to not change. Namely:
    </p>
    <ul>
      <li>detector/config/auto_summation = true</li>
      <li>stream/config/header_detail = "none"</li>
      <li>filewriter/config/image_nr_start = 1</li>
      <li>monitor/config/buffer_size = 1</li>
    </ul>

  <h2 id="Trigger_Modes">Trigger Modes</h2>
    <p>
      There are four trigger modes available:
      <ul>
        <li> <b>Internal Series</b>: one internal trigger pulse generates N images </li>
        <li> <b>Internal Enable</b>: one internal trigger pulse generates one image</li>
        <li> <b>External Series</b>: one external trigger pulse generates N images</li>
        <li> <b>External Enable</b>: one external trigger pulse generates one image</li>
      </ul>
    </p>
    <p>
      The total number of images generated by <b>Internal</b> and <b>External Series</b> modes is given by the product
      of the NumImages and NumTriggers PVs (<i>nimages</i> and <i>ntriggers</i> in Dectris terminology).
    </p>
    <p>
      On both <b>Internal</b> and <b>External Enable</b> modes the total number of images generated is given solely by
      the NumTriggers PV (<i>ntriggers</i>). NumImages is set to 1 temporarily during the acquisition.
    </p>
    <p>
      Triggers for <b>Internal Enable</b> mode are sent by processing the Trigger PV. The exposure for each individual
      image is given by the TriggerExposure PV and can change between triggers in the same acquisition. This mode is
      experimental as of firmware 1.5.0. See Known Issues.
    </p>
    <p>
      On <b>External Series</b> and <b>External Enable</b> modes there is currently (as of firmware 1.5.0) no way of
      knowing if the detector is done receiving triggers and needs a disarm. Therefore, the acquisition must be stopped
      (Acquire=0) manually.
    </p>

  <h2 id="Manual_Trigger">Manual Trigger</h2>
  <p>
    On <b>Internal Series</b> and <b>Internal Enable</b> modes, if the ManualTrigger PV is set to YES, the triggers are
    not auto generated by the driver. Instead, they are sent by processing the Trigger PV. On <b>Internal Enable</b>
    mode the trigger carries an exposure value that can change for each trigger, which is set by the TriggerExposure PV.
    Note that the <b>Internal Enable</b> mode is experimental as of firmware 1.5.0, see Known Issues.
  </p>

  <h2 id="Data_Acquisition">Data Acquisition</h2>
    <p>
      Data generated by the Eiger can be pulled from the detector in a number of ways. The detector has three modules
      (in Dectris' terminology) that make the results of the acquisition available in different ways. The <b>FileWriter
      </b> module writes the generated images to the detector disk as HDF5 files that consist of a master (header) file
      and a number of data files. The <b>Stream</b> module makes the images available as soon as they are captured as a
      ZeroMQ stream. The <b>Monitor</b> module produces TIFF images every so often to monitor how a long acquisition is
      progressing.
    </p>
    <p>
      Data from the FileWriter or from the Stream mode can be parsed into NDArrays for the areaDetector pipeline. The
      actual source is selected with the DataSource PV. If DataSource is set to None, however, no data will be sent
      to the areaDetector pipeline but the detector will still be controllable via the areaDetector driver;
      third-party clients can then pull files or listen to the ZeroMQ stream independently of this driver.
    </p>
    <h3 id="Using_FileWriter">Using FileWriter</h3>
    <p>
      The FileWriter module is activated when FWEnable is set to Yes. Files generated by the FileWriter have names
      according to the FWNamePattern PV. The default pattern is "series_$id", where $id is replaced by the Sequence ID
      of the acquisition. A master file is generated as soon as the detector is successfully armed. A number of data
      files follow. The number of data files generated depends on the total number of images of the acquisition and
      the FWNFilesPerImage PV.
    </p>
    <p>
      For example, if TriggerMode is <b>External Enable</b>, NumImages is 60, NumTriggers is 2, FWNImagesPerFIle is 100,
      Sequence ID for the acquisition is 1 and FWNamePattern is "series_$id", a total of three files will be generated:
      series_1_master.h5, series_1_data_000001.h5 (with 100 images) and series_1_data_000002.h5 (with 20 images).
    </p>
    <p>
      The generated files will be downloaded either if DataSource is set to FileWriter or if SaveFiles is set to Yes.
      Files are downloaded as soon as they are available. To determine if a file is available the driver polls the
      detector at a nominal rate of 10Hz. While a file is being processed the next file available is downloaded in
      parallel. All files will remain on the detector disk unless FWAutoRemove is set to Yes.
    </p>
    <p>
      All files on the detector disk can be deleted at once by processing the FWClear PV.
    </p>
    <p>
      If the last data file of a series won't be full (e.g. series_1_data_000002.h5 with 20 images) then it will only
      appear on the detector disk after a disarm command (issued when the acquisition is stopped), which flushes the
      FileWriter buffer.
    </p>
    <h3 id="Using_Stream">Using Stream</h3>
    <p>
      The Stream module is activated when StreamEnable is set to Yes. Data will then be available on the detector's tcp
      port 9999 as a ZMQ_PUSH socket. If DataSource is set to Stream, this driver opens a corresponding ZMQ_PULL socket
      and parses the incoming data as NDArrays. Otherwise a third-party client can listen on that socket for data. The
      format of the packets is specified in the Eiger SIMPLON API documentation.
    </p>
    <h3 id="Using_Monitor">Using Monitor</h3>
    <p>
      The Monitor module is activated when MonitorEnable is set to Yes. Data will be available whenever the monitor
      module buffer is full (has one image available). This driver polls the detector at a rate set by MonitorPeriod
      to know when data is available. Once downloaded, the TIFF image is parsed into areaDetector's NDArray on
      NDArrayAddr 1 (therefore, an independent NDArray stream).
    </p>

  <h2 id="Chrystallography_Parameters">Chrystallography Parameters</h2>
  <p>
    A few parameters are available as metadata for the acquisition. These values are stored on the master file and
    sent as metadata in ZeroMQ stream, but otherwise don't affect the acquisition, with the exception of the Wavelength
    parameter, which sets Photon Energy accordingly.
  </p>
  <h2 id="StandardNotes" style="text-align: left">Implementation of standard driver parameters</h2>
    <p>
      The following table describes how the Andor driver implements some of the standard
      driver parameters.
    </p>
    <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
      <tbody>
        <tr>
          <td align="center" colspan="4">
            <b>Implementation of Parameters in asynNDArrayDriver.h and ADDriver.h, and EPICS Record
              Definitions in ADBase.template and NDFile.template</b></td>
        </tr>
        <tr>
          <th>Parameter index variable</th>
          <th>EPICS record name</th>
          <th>Eiger Parameter</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>ADTriggerMode</td>
          <td>
            $(P)$(R)TriggerMode<br/>
            $(P)$(R)TriggerMode_RBV</td>
          <td>detector/config/trigger_mode</td>
          <td>
            Sets the trigger mode for the detector. Options are:
            <ul>
              <li>Internal Series</li>
              <li>Internal Enable</li>
              <li>External Series</li>
              <li>External Enable</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>ADNumImages</td>
          <td>
            $(P)$(R)NumImages<br/>
            $(P)$(R)NumImages_RBV
          </td>
          <td>detector/config/nimages</td>
          <td> Sets the number of images to take per trigger when on Internal Series or External Series mode.</td>
        </tr>
        <tr>
          <td>ADAcquireTime</td>
          <td>
            $(P)$(R)AcquireTime<br/>
            $(P)$(R)AcquireTime_RBV
          </td>
          <td>detector/config/count_time</td>
          <td>
            Sets the parameter "count_time", which is the exposure time for a single image
            on INTS or EXTS mode.
          </td>
        </tr>
        <tr>
          <td>ADAcquirePeriod</td>
          <td>
            $(P)$(R)AcquirePeriod<br />
            $(P)$(R)AcquirePeriod_RBV
          </td>
          <td>detector/config/frame_time</td>
          <td>
            Sets the parameter "frame_time", which directly affects the frame rate of the detector.
            The resulting frame rate will be 1/AcquirePeriod.
          </td>
        </tr>
        <tr>
          <td>NDDataType</td>
          <td>$(P)$(R)DataType_RBV</td>
          <td></td>
          <td>
            The data type of the image data. If AcquireTime results in less than 50Hz, this will have the value UInt16,
            otherwise UInt32.
          </td>
        </tr>
        <tr>
          <td>ADTemperatureActual</td>
          <td> $(P)$(R)TemperatureActual</td>
          <td>detector/status/board_000/th0_temp</td>
          <td> Reads the actual temperature of the detector.</td>
        </tr>
        <tr>
          <td>ADSizeX<br>ADMaxSizeX<br>NDArraySizeX</td>
          <td>$(P)$(R)SizeX_RBV<br>$(P)$(R)MaxSizeX_RBV<br>$(P)$(R)ArraySizeX_RBV</td>
          <td>detector/config/x_pixels_in_detector</td>
          <td>Reads the detector sensor size in the X direction.</td>
        </tr>
        <tr>
          <td>ADSizeY<br>ADMaxSizeY<br>NDArraySizeY</td>
          <td>$(P)$(R)SizeY_RBV<br>$(P)$(R)MaxSizeY_RBV<br>$(P)$(R)ArraySizeY_RBV</td>
          <td>detector/config/y_pixels_in_detector</td>
          <td>Reads the detector sensor size in the Y direction.</td>
        </tr>
        <tr>
          <td>ADManufacturer<br>ADModel</td>
          <td>$(P)$(R)Manufacturer_RBV<br>$(P)$(R)Model_RBV</td>
          <td>detector/config/description</td>
          <td>Reads the detector manufacturer (Dectris) and model (Eiger xx M).</td>
        </tr>
      </tbody>
    </table>
  <h2 id="Driver_parameters" style="text-align: left">Eiger specific parameters</h2>
    <p>
      The Eiger driver implements the following parameters in addition to those in asynNDArrayDriver.h
      and ADDriver.h.
    </p>
    <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
      <tbody>
        <tr>
          <td align="center" colspan="7">
            <b>Parameter Definitions in eigerDetector.cpp and EPICS Record Definitions in eiger.template</b>
          </td>
        </tr>
        <tr>
          <th> Parameter index variable</th>
          <th> Eiger Parameter</th>
          <th> asyn interface</th>
          <th> Access</th>
          <th> Description</th>
          <th> drvInfo string</th>
          <th> EPICS record name</th>
          <th> EPICS record type</th>
        </tr>
        <tr>
          <td align="center" colspan="8"> <b>Version information</b> </td>
        </tr>
        <tr>
          <td> EigerSerialNumber</td>
          <td> detector/config/detector_number</td>
          <td> asynOctet</td>
          <td> R/O</td>
          <td> Detector serial number</td>
          <td> SERIAL_NUMBER</td>
          <td> SerialNumber_RBV</td>
          <td> stringin</td>
        </tr>
        <tr>
          <td> EigerSWVersion</td>
          <td> detector/config/software_version</td>
          <td> asynOctet</td>
          <td> R/O</td>
          <td> Detector firmware version</td>
          <td> SW_VERSION</td>
          <td> SWVersion_RBV</td>
          <td> stringin</td>
        </tr>
        <tr>
          <td align="center" colspan="8"> <b>Status parameters</b> </td>
        </tr>
        <tr>
          <td> EigerState</td>
          <td> detector/status/state</td>
          <td> asynOctet</td>
          <td> R/O</td>
          <td> State of the detector</td>
          <td> STATE</td>
          <td> State_RBV</td>
          <td> stringin</td>
        </tr>
        <tr>
          <td> EigerError</td>
          <td> detector/status/error</td>
          <td> asynOctet</td>
          <td> R/O</td>
          <td> List of parameters causing an error state</td>
          <td> ERROR</td>
          <td> Error_RBV</td>
          <td> stringin</td>
        </tr>
        <tr>
          <td> EigerDCUBufferFree</td>
          <td> detector/status/builder/dcu_buffer_free</td>
          <td> asynFloat64</td>
          <td> R/O</td>
          <td> Percentage of the detector's internal buffer that is free.
               Low values may indicate a problem.</td>
          <td> DCU_BUF_FREE</td>
          <td> DCUBufferFree_RBV</td>
          <td> ai</td>
        </tr>
        <tr>
          <td> EigerThTemp0</td>
          <td> detector/status/board_000/th0_temp</td>
          <td> asynFloat64</td>
          <td> R/O</td>
          <td> Temperature of the first module</td>
          <td> TH_TEMP_0</td>
          <td> Temp0_RBV</td>
          <td> ai</td>
        </tr>
        <tr>
          <td> EigerThHumid0</td>
          <td> detector/status/board_000/th0_humidity</td>
          <td> asynFloat64</td>
          <td> R/O</td>
          <td> Humidity of the first module</td>
          <td> TH_HUMID_0</td>
          <td> Humid0_RBV</td>
          <td> ai</td>
        </tr>
        <tr>
          <td> EigerLink0<br>
               EigerLink1<br>
               EigerLink2<br>
               EigerLink3</td>
          <td> detector/status/link_0<br>
               detector/status/link_1<br>
               detector/status/link_2<br>
               detector/status/link_3</td>
          <td> asynInt32</td>
          <td> R/O</td>
          <td> Status of the four links between the detector server and the head</td>
          <td> LINK_0<br>
               LINK_1<br>
               LINK_2<br>
               LINK_3</td>
          <td> Link0_RBV<br>
               Link1_RBV<br>
               Link2_RBV<br>
               Link3_RBV</td>
          <td> bi</td>
        </tr>
        <tr>
          <td align="center" colspan="8"> <b>FileWriter control</b> </td>
        </tr>
        <tr>
          <td> EigerFWEnable</td>
          <td> filewriter/config/mode</td>
          <td> asynInt32</td>
          <td> R/W</td>
          <td> Enables or disables the FileWriter module</td>
          <td> FW_ENABLE</td>
          <td> FWEnable<br>FWEnable_RBV</td>
          <td> bo<br>bi</td>
        </tr>
        <tr>
          <td> EigerFWClear</td>
          <td> filewriter/config/clear</td>
          <td> asynInt32</td>
          <td> W/O</td>
          <td> Writing to this PV clears *all* files on the detector server disk</td>
          <td> CLEAR</td>
          <td> FWClear</td>
          <td> ao</td>
        </tr>
        <tr>
          <td> EigerFWCompression</td>
          <td> filewriter/config/compression_enabled</td>
          <td> asynInt32</td>
          <td> R/W</td>
          <td> Enables or disables LZ4 compression on the server side </td>
          <td> COMPRESSION</td>
          <td> FWCompression<br/>FWCompression_RBV</td>
          <td> bo<br/>bi</td>
        </tr>
        <tr>
          <td> EigerFWNamePattern</td>
          <td> filewriter/config/name_patttern</td>
          <td> asynOctet</td>
          <td> R/W</td>
          <td>
              Name pattern for the generated HDF5 files. The pattern can be anything, but it
              must contain the string '$id' in it. This string is replaced with the current
              sequence id of the acquisition. The default is: "series_$id", which would generate
              the files:<br/>
              <ul>
                  <li>series_1_master.h5</li>
                  <li>series_1_data_000001.h5</li>
                  <li>series_1_data_000002.h5</li>
                  <li>...</li>
              </ul>
              For the sequence id 1. If '$id' is omitted, files might get overwritten on the
              server, because then every acqusition would generate files with the same name
          </td>
          <td> NAME_PATTERN</td>
          <td> FWNamePattern<br/>FWNamePattern_RBV</td>
          <td> stringout<br/>stringin</td>
        </tr>
        <tr>
          <td> EigerFWNImagesPerFile</td>
          <td> filewriter/config/nimages_per_file</td>
          <td> asynInt32</td>
          <td> R/W</td>
          <td> Number of images per HDF5 data file </td>
          <td> NIMAGES_PER_FILE</td>
          <td> FWNImgsPerFile<br/>FWNImgsPerFile_RBV</td>
          <td> ao<br/>ai</td>
        </tr>
        <tr>
          <td> EigerFWAutoRemove</td>
          <td></td>
          <td> asynInt32</td>
          <td> R/W</td>
          <td> Controls wheter downloaded files should be removed from the detector disk </td>
          <td> AUTO_REMOVE</td>
          <td> FWAutoRemove<br/>FWAutoRemove_RBV</td>
          <td> bo<br/>bi</td>
        </tr>
        <tr>
          <td> EigerFWFree</td>
          <td> filewriter/status/buffer_free</td>
          <td> asynFloat64</td>
          <td> R/O</td>
          <td> Free space on detector disk.</td>
          <td> FW_FREE</td>
          <td> FWFree_RBV</td>
          <td> ai</td>
        </tr>
        <tr>
          <td align="center" colspan="8"> <b>Stream control</b> </td>
        </tr>
        <tr>
          <td> EigerStreamEnable</td>
          <td> stream/config/mode</td>
          <td> asynInt32</td>
          <td> R/W</td>
          <td> Enables or disables the Stream module</td>
          <td> STREAM_ENABLE</td>
          <td> StreamEnable<br>StreamEnable_RBV</td>
          <td> bo<br>bi</td>
        </tr>
        <tr>
          <td> EigerStreamDropped</td>
          <td> stream/status/dropped</td>
          <td> asynInt32</td>
          <td> R/O</td>
          <td> Indicates how many images were dropped in the last acquisition</td>
          <td> STREAM_DROPPED</td>
          <td> StreamDropped_RBV</td>
          <td> ai</td>
        </tr>
        <tr>
          <td align="center" colspan="8"> <b>Monitor control</b> </td>
        </tr>
        <tr>
          <td> EigerMonitorEnable</td>
          <td> monitor/config/mode</td>
          <td> asynInt32</td>
          <td> R/W</td>
          <td> Enables or disables the Monitor module</td>
          <td> MONITOR_ENABLE</td>
          <td> MonitorEnable<br>MonitorEnable_RBV</td>
          <td> bo<br>bi</td>
        </tr>
        <tr>
          <td> EigerMonitorPeriod</td>
          <td></td>
          <td> asynFloat64</td>
          <td> R/W</td>
          <td> Time between queries on the Monitor interface for new images</td>
          <td> MONITOR_PERIOD</td>
          <td> MonitorPeriod<br>MonitorPeriod_RBV</td>
          <td> ao<br>ai</td>
        </tr>
        <tr>
          <td align="center" colspan="8"> <b>Acquisition metadata</b> </td>
        </tr>
        <tr>
          <td> EigerBeamX</td>
          <td> detector/config/beam_center_x</td>
          <td> asynFloat64</td>
          <td> R/W</td>
          <td> X position of the beam </td>
          <td> BEAM_X</td>
          <td> BeamX<br/>BeamX_RBV</td>
          <td> ao<br/>ai</td>
        </tr>
        <tr>
          <td> EigerBeamY</td>
          <td> detector/config/beam_center_y</td>
          <td> asynFloat64</td>
          <td> R/W</td>
          <td> Y position of the beam </td>
          <td> BEAM_Y</td>
          <td> BeamY<br/>BeamY_RBV</td>
          <td> ao<br/>ai</td>
        </tr>
        <tr>
          <td> EigerDetDist</td>
          <td> detector/config/detector_distance</td>
          <td> asynFloat64</td>
          <td> R/W</td>
          <td> Detector distance </td>
          <td> DET_DIST</td>
          <td> DetDist<br/>DetDist_RBV</td>
          <td> ao<br/>ai</td>
        </tr>
        <tr>
          <td> EigerWavelength</td>
          <td> detector/config/wavelength</td>
          <td> asynFloat64</td>
          <td> R/W</td>
          <td>
              Wavelength of the beam. This parameter is automatically changed
              whenever the PhotonEnergy changes
          </td>
          <td> WAVELENGTH</td>
          <td> Wavelength<br/>Wavelength_RBV</td>
          <td> ao<br/>ai</td>
        </tr>
        <tr>
          <td align="center" colspan="8"> <b>Acquisition control</b> </td>
        </tr>
        <tr>
          <td> EigerDataSource</td>
          <td> </td>
          <td> asynInt32</td>
          <td> R/W</td>
          <td> Which data source to use for areaDetecor pipeline.
               Valid values:
               <ul>
               <li>None</li>
               <li>FileWriter</li>
               <li>Stream</li> </td>
          <td> DATA_SOURCE</td>
          <td> DataSource<br>DataSource_RBV</td>
          <td> mbbo<br>mbbi</td>
        </tr>
        <tr>
          <td> EigerArmed</td>
          <td> </td>
          <td> asynInt32</td>
          <td> R/O</td>
          <td> Armed state of the detector </td>
          <td> ARMED</td>
          <td> Armed</td>
          <td> bi</td>
        </tr>
        <tr>
          <td> EigerSaveFiles</td>
          <td></td>
          <td> asynInt32</td>
          <td> R/W</td>
          <td> Controls wheter acquired files should be saved locally to disk </td>
          <td> SAVE_FILES</td>
          <td> SaveFiles<br/>SaveFiles_RBV</td>
          <td> bo<br/>bi</td>
        </tr>
        <tr>
          <td> EigerSequenceId</td>
          <td></td>
          <td> asynInt32</td>
          <td> R/O</td>
          <td> Sequence ID of the current acquisition</td>
          <td> SEQ_ID</td>
          <td> SequenceId</td>
          <td> ai</td>
        </tr>
        <tr>
          <td> EigerFlatfield</td>
          <td> detector/config/flatfield_correction_applied</td>
          <td> asynInt32</td>
          <td> R/W</td>
          <td> Controls wheter the flatfield correction should be applied </td>
          <td> FLATFIELD_APPLIED</td>
          <td> FlatfieldApplied<br/>FlatfieldApplied_RBV</td>
          <td> bo<br/>bi</td>
        </tr>
        <tr>
          <td> EigerPhotonEnergy</td>
          <td> detector/config/photon_energy</td>
          <td> asynFloat64</td>
          <td> R/W</td>
          <td> Photon energy for the acquisition </td>
          <td> PHOTON_ENERGY</td>
          <td> PhotonEnergy<br/>PhotonEnergy_RBV</td>
          <td> ao<br/>ai</td>
        </tr>
        <tr>
          <td> EigerThreshold</td>
          <td> detector/config/threshold_energy</td>
          <td> asynFloat64</td>
          <td> R/W</td>
          <td> Energy threshold for the acquisition</td>
          <td> THRESHOLD</td>
          <td> Threshold<br/>Threshold_RBV</td>
          <td> ao<br/>ai</td>
        </tr>
        <tr>
          <td> EigerTrigger</td>
          <td> detector/command/trigger</td>
          <td> asynInt32</td>
          <td> W/O</td>
          <td> Software trigger to be used on modes INTS and INTE when ManualTrigger is set</td>
          <td> TRIGGER</td>
          <td> Trigger</td>
          <td> ao</td>
        </tr>
        <tr>
          <td> EigerTriggerExp</td>
          <td> detector/command/trigger</td>
          <td> asynFloat64</td>
          <td> R/W</td>
          <td> Exposure to be used with the triggers on the INTE mode</td>
          <td> TRIGGER_EXPOSURE</td>
          <td> TriggerExposure<br/>TriggerExposure_RBV</td>
          <td> ao<br/>ai</td>
        </tr>
        <tr>
          <td> EigerNTriggers</td>
          <td> detector/config/ntrigger</td>
          <td> asynInt32</td>
          <td> R/W</td>
          <td> Number of triggers for the acquisition</td>
          <td> NUM_TRIGGERS</td>
          <td> NumTriggers<br/>NumTriggers_RBV</td>
          <td> ao<br/>ai</td>
        </tr>
        <tr>
          <td> EigerManualTrigger</td>
          <td></td>
          <td> asynInt32</td>
          <td> R/W</td>
          <td>
              On INTS and INTE modes, controls whether triggers will be issued automatically (0)
              or only via the Trigger PV (1).
          </td>
          <td> MANUAL_TRIGGER</td>
          <td> ManualTrigger<br/>ManualTrigger_RBV</td>
          <td> bo<br/>bi</td>
        </tr>
      </tbody>
    </table>

  <h2 id="Unsupported" style="text-align: left"> Unsupported standard driver parameters</h2>
    <p> All standard parameters not mentioned in this document are not supported.</p>

  <h2 id="Configuration"> Configuration</h2>
    <p>
      The Eiger driver is created with the eigerDetectorConfig command, either from C/C++ or
      from the EPICS IOC shell.</p>
    <pre>int eigerDetectorConfig(const char *portName, const char *hostname,
                  int maxBuffers, size_t maxMemory, int priority, int stackSize)
    </pre>
    <p>
      For details on the meaning of the parameters to this function refer to the detailed
      documentation on the eigerDetectorConfig function in the <a href="areaDetectorDoxygenHTML/eiger_detector_8cpp.html">
        eigerDetector.cpp documentation</a> and in the documentation for the constructor for
      the <a href="areaDetectorDoxygenHTML/classeiger_detector.html">eigerDetector class</a>
    </p>
    <p> There an example IOC boot directory and startup script provided with areaDetector. </p>
  <h2 id="CSS_screen" style="text-align: left"> CSS screen</h2>
    <p>
      The following shows the CSS screen that is used to control the Eiger detector.
      Note that the general purpose screen ADBase.adl can be used, but it exposes a few
      controls that are not applicable to the Eiger, and lacks some fields that are important
      for the Eiger.</p>
    <p>
      <code>eiger.opi</code> is the main screen used to control the Eiger driver.
    </p>
    <div style="text-align: center">
      <h3 style="text-align: center"> eiger.opi</h3>
      <img alt="eiger.png" src="eiger.png" />
    </div>

  <h2 id="Known_Issues" style="text-align: left"> Known Issues</h2>
    <h3 id="Changing_the_Photon_Energy">Changing the Photon Energy</h3>
      <p>
        Changing the Photon Energy is a potentially slow operation, depending on the detector size. On the 16M it takes
        around ten seconds. Other parameters also take this long because they also affect the Photon Energy, namely
        Threshold Energy and Wavelength. The StatusMessage PV indicates when setting any of these parameters start and
        finish.
      </p>

    <h3 id="Status_Parameters_Polling">Status Parameters Polling</h3>
    <p>
      A few status parameters are read every time the ReadStatus PV is processed. A high rate polling causes issues,
      sometimes causing the detector to hang when, in conjunction, a parameter is set to an invalid value.
    </p>

    <h3 id="Internal_Enable_Mode">Internal Enable Mode</h3>
    <p>
      The Internal Enable mode is marked as experimental by Dectris. At the moment it is very flaky (firmware 1.5.0) and
      often doesn't generate all the files it is supposed to.
    </p>
</body>
</html>
